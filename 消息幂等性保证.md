# 消息幂等性保证

## 1 传输保证机制

对于确保消息在生产者和消费者之间进行传输而言一般有三种传输保障（delivery guarantee）：

- **At least once**:至少一次，消息绝不会丢，但是可能会重复；
- **Exactly once**:精确一次，每条消息肯定会被传输一次且仅一次。

对于大多数消息中间件而言，**一般只提供At most once和At least once两种传输保障**，对于第三种一般很难做到，由此消息幂等性也很难保证。

**Kafka自0.11版本开始引入了幂等性和事务，Kafka的幂等性是指单个生产者对于单分区单会话的幂等，而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让Kafka具备EOS（Exactly Once Semantic）的能力。**

我们实现消息的幂等性一般都是通过下游消费的代码来实现其幂等性:



## 2 出现非幂等的情况 

1. **生产者已把消息发送到mq**，在mq给生产者返回ack的时候网络中断，故生产者未收到确定信息，生产者认为消息未发送成功，但实际情况是，mq已成功接收到了消息，在网络重连后，生产者会重新发送刚才的消息，造成mq接收了重复的消息
2. **消费者在消费mq中的消息时，mq已把消息发送给消费者**，消费者在给mq返回ack时网络中断，故mq未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息；

## 3 实现幂等必备条件

- 全局唯一的id
- 根据全局唯一id滤重

## 4 具体实现方式

### 4.1 全局唯一id

生成全局以为id的方式有很多:

- 可以生成一个与业务无关的全局id,比如使用twitter的雪花算法
- 也可以根据业务来指定全局唯一id,比如使用订单号,用户唯一id等



### 4.2 根据全局唯一id滤重 

可以使用的方式:

1. **如果使用的是业务id来做全局唯一**，那么可以在业务表字段加上唯一约束条件，**每次操作时有就更新,没有就插入**
2. **添加消息表**:再数据库里面，添加一张消息消费记录表，表字段加上唯一约束条件,消费完之后就往表里插入一条数据。因为加了唯一约束条件，第二次保存的时候，MySQL 就会报错，就插入不进去；通过数据库可以限制重复消费。
3. **使用Redis的Set类型保存消费过的id**,每次操作前先查一下是否在set中,如果在,则过滤



### 4.3 高并发下需要考虑的问题

在高并发下,消费端消费id=2的数据过程中,**还没有使用上面的方式将全局唯一id加入滤重复表**,也有可能造成重复消费的情况,此时我们需要考虑在消费消息前加入**分布式锁(Redis/Zookeeper实现)**,先判断是否有锁,如果有锁则等待

