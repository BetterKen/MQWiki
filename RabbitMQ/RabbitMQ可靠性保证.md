# RabbitMQ数据可靠性保证

## 1 生产者可靠性保证

在使用RabbitMQ的时候，我们可以通过消息持久化操作来解决因为服务器的异常奔溃导致的消息丢失，除此之外我们还会遇到一个问题，当消息的发布者在将消息发送出去之后，消息到底有没有正确到达broker代理服务器

如果不进行特殊配置的话，默认情况下发布操作**是不会返回任何信息给生产者的**，也就是默认情况下我们的生产者是不知道消息有没有正确到达broker的，如果在消息到达broker之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器，你怎么进行持久化，那么这个问题该怎么解决呢？

RabbitMQ为我们提供了两种方式：

- 通过AMQP**事务机制**实现，这也是AMQP协议层面提供的解决方案；
- 通过将channel设置成**confirm模式**来实现；

### 1.1 事务机制

选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。

```java
// 开启事务
channel.txSelect
try {
    // 这里发送消息
} catch (Exception e) {
    channel.txRollback

    // 这里再次重发这条消息
}

// 提交事务
channel.txCommit
```

但是问题是，RabbitMQ 事务机制（同步）一搞，基本上**吞吐量会下来，因为太耗性能**。



### 1.2 Comfirm机制

生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。

confirm模式最大的好处在于他是**异步的**，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。

在channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack 。

#### 1.2.1 编程模式

confirm有三种编程方式：

- **批量confirm模式**：每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。
- **异步confirm模式**：提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法(推荐使用的)

## 2 消费者可靠性保证

在Consumer中Confirm模式中分为

- 手动确认
- 自动确认

### 2.1 自动确认

默认模式是自动确认模式:消息在发送后立即被认为是发送成功。 这种模式可以提高吞吐量（只要消费者能够跟上），不过会降低投递和消费者处理的安全性。 这种模式通常被称为“发后即忘”。 与手动确认模式不同，如果消费者的TCP连接或信道在成功投递之前关闭，该消息则会丢失。

### 2.２ 手动确认

为了保证消息从队列可靠地到达消费者，RabbitMQ提供消息确认机制(message acknowledgment)。消费者在声明队列时，可以指定noAck参数，当**noAck=false时，RabbitMQ会等待消费者显式发回ack信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息**。否则，RabbitMQ会在队列中消息被消费后**立即删除**它。

采用消息确认机制后，只要令noAck=false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用basicAck为止。

当noAck=false时，对于RabbitMQ服务器端而言，队列中的消息分成了两部分：

- 一部分是等待投递给消费者的消息；

- 一部分是已经投递给消费者，但是还没有收到消费者ack信号的消息。

RabbitMQ**不会为没有ack确认的消息设置超时时间**，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。

**建议使用手动模式**

- 如果服务器端**一直没有收到消费者的ack信号，并且消费此消息的消费者已经断开连接**，则服务器端会**安排该消息重新进入队列，靠近队列头位置**，等待投递给下一个消费者（也可能还是原来的那个消费者）。
- 如果收到了**nack/reject信号且requeue为true**,服务器端也会**安排该消息重新进入队列，靠近队列头位置**，等待投递给下一个消费者（也可能还是原来的那个消费者）。
- 如果收到了**nack/reject信号且requeue为false**,则**进入死信队列**

## 3 broke可靠性保证

broke可靠性需要两方面保证:

- 持久化保证
- 集群高可用保证

### 3.1 持久化保证

就是 RabbitMQ 自己弄丢了数据，这个你必须**开启 RabbitMQ 的持久化**，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。

设置持久化有两个步骤：

- **创建 queue 的时候将其设置为持久化**,这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的
- 发送消息的时候将消息的 **deliveryMode 设置为 2**就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。

**必须要同时设置这两个持久化才行**，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。

注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。

所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。



### 3.2 集群高可用

**开启镜像高可用模式**。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，**每个 RabbitMQ 节点都有这个 queue 的一个完整镜像**，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。



## 4 总结

![](http://dist415.oss-cn-beijing.aliyuncs.com/rmqsis.png)










