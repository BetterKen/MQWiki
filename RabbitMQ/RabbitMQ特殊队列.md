# RabbitMQ特殊队列

- 死信队列
- 延时队列
- 优先级队列

## 1 死信队列

DLX, Dead-Letter-Exchange

利用DLX, 当消息在一个队列中变成死信（dead message）之后，它能被重新publish到**另一个Exchange**，这个Exchange就是DLX。

### 1.1 产生情况

消息变成死信一向有一下几种情况:

- **消息被拒绝（basic.reject/ basic.nack）并且requeue=false**
- **消息TTL过期**
- **队列达到最大长度**



### 1.2 特性

- DLX也是一个**正常的Exchange**,和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。
- 当这个队列中有死信时，RabbitMQ就会**自动的将这个消息重新发布**到设置的Exchange上去，进而被路由到另一个队列。
- **可以监听这个队列中消息**做相应的处理，这个特性可以弥补RabbitMQ3.0以前支持的immediate参数的功能。

### 1.3 设置

- 首先需要设置死信队列的exchange和queue,然后进行绑定:
  - Exchange: dlx.exchange
  - Queue: dlx.queue
  - Routing Key: #
- 然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列加上一个参数即可：arguments.put(nx-dead-letter-exchange","dlx.exchange")；
- 这样消息在过期、requeue、队列在达到最大长度时，消息就可以直接路由到死信队列

## 2 延时队列

延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。

延迟队列的使用场景有很多，比如：

- 在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了。
- 用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到智能设备。



## 3 优先级队列

